
以下のようにすれば`class`キーワードを使わずにクラスを定義できる。

```ruby
c = Class.new(Array) do
  def my_method
    'Hello!'
  end
end
```

この場合、cは無名のClassオブジェクトを参照してるってことになる。

```ruby
pry> c.class
=> Class
pry> c.superclass
=> Array
pry> c.name
=> nil
```

これを定数に代入した時に、Rubyはいろいろよしなにしてくれる。「このClassオブジェクトは~って名前だよ！」って紐付けしてくれる。

```ruby
pry> MyClass = c
pry> c.name
=> "MyClass"
```

## ダックタイピング

簡単に言えば「そのオブジェクトがDuckクラスのインスタンスかどうかなんて気にせずにプログラミングを進めていく」こと。

通常のメソッドでも、特異メソッドでも、たとえゴーストメソッドでも、そのアヒルがwalk()とquack()に反応するかどうかさえ気にしてればいい。


## クラスメソッド

**クラスメソッドは、Classオブジェクトの特異メソッド**である。(重要！)

クラス定義にコードを書くと、クラスがselfになる。だからクラスメソッドを定義するときは`self`を使うんだ！

```ruby
class MyClass
  def self.yet_another_class_method
end
```

だからクラスメソッドだって(オブジェクトの)特異メソッドだって、全部仕組みは同じなんだ！


## Rubyのオブジェクトモデル

### 特異クラスを発見する

特異クラスを発見するのは難しい。そいつをRubyはうまいこと隠そうとするからだ。

だけど、特異クラスの姿をあらわにするための構文を用意してくれている。以下で特異クラスのスコープに連れて行ってくれる。`class << obj`の構文を使って特異クラスを引っ張り出してみる。

```ruby
obj = Object.new
eigenclass = class << obj
  self
end
```

```
eigenclass.class
=> Class
```

特異クラスは、Classであることが分かった。そして、特異クラスは、ひとつのインスタンスしか持つことができない。(だからシングルトンクラスとも呼ばれる)

この**特異クラスが、オブジェクトの特異メソッドが住んでいる場所**だ。

以下のようにすれば、特異クラスを返すヘルパーメソッドを定義できる。


```ruby
class Object
  def eigenclass
    class << self: self: end
  end
end
```

```ruby
"abc".eigenclass # => #<Class:#<String:0x331df0>
```


## 大統一理論

Rubyのオブジェクトモデルの理論は、以下の7つに集約することができる。

1. オブジェクトは1種類しかない。それが通常のオブジェクトかモジュールになる。
2. モジュールは1種類しかない。それが通常のモジュール、クラス、特異クラス、プロキシクラスのいずれかになる。
3. メソッドは1種類しかない。メソッドはモジュール(大半はクラス)に住んでいる。
4. すべてのオブジェクトは、クラスも含め「本物のクラス」を持っている。それは、通常のクラスか特異クラスになる。
5. すべてのクラスはBasicObject(Ruby1.8以前ならObject)を除いてスーパークラスを持っている。あらゆるクラスがBasicObjectに向かって一本の継承チェーンを持っている。
6. オブジェクトの特異クラスのスーパークラスは、オブジェクトのクラスである。クラスの特異クラスのスーパークラスは。クラスのスーパークラスの特異クラスである。
7. メソッドを呼び出すとき、Rubyはレシーバの本物のクラスに向かって、「右へ」進み、継承チェーンを「上へ」進む。
